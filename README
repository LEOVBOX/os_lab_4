Адресное пространство процесса

1. Структура адресного пространства.
    a. Напишите программу, которая создает переменные и выводит их адреса:
        1. локальные в функции;
        2. статические в функции;
        3. константы в функции;
        4. глобальные инициализированные;
        5. глобальные неинициализированные;
        6. глобальные константы.
    b. Сопоставьте адреса переменных с областями адресного пространства из соответствующего /proc/<pid>/maps. Объясните увиденное.
    c. Используя утилиту nm (или readelf) определите в каких секциях находятся выделенные переменные переменные.
    d. Напишите функцию, которая создает и инициализирует локальную переменную и возвращает ее адрес. Прокомментируйте результат и дайте оценку происходящему.
    e. Напишите функцию, которая:
        1. выделяет на куче буфер (например, размером 100 байт);
        2. записывает в него какую-либо фразу (например, hello world);
        3. выводит содержимое буфера;
        4. освобождает выделенную память;
        5. снова выводит содержимое буфера;
        6. выделяет еще один буфер;
        7. записывает в них какую-либо фразу (например, hello world);
        8. выводит содержимое буфера;
        9. перемещает указатель на середину буфера;
        10. освобождает память по этому указателю.
        11. выводит содержимое буфера;
    f. Прокомментируйте работу предыдущего пункта.
    g. Заведите переменную окружения.
    h. Добавьте в вашу программу код, который:
        1. распечатывает ее значение;
        2. изменяет ее значение;
        3. повторно распечатывает ее значение.
    i. Запустите вашу программу и убедитесь что переменная окружения
    имеет требуемое значение.
    j. Выведите значение переменной окружения после того как ваша
    программа завершилась.
    k. Объясните произошедшее.

2. Управление адресным пространством:
   a. Напишите программу, которая:
       1. выводит pid процесса;
       2. ждет одну секунду;
       3. делает exec(2) самой себя;
       4. выводит сообщение “Hello world”
   b. Понаблюдайте за выводом программы и содержимым соответствующего файла /proc/<pid>/maps. Объясните происходящее.
   c. Напишите программу, которая:
       1. выводит pid процесса;
       2. ждет 10 секунд (подберите паузу чтобы успеть начать мониторить
       адресное пространство процесса, например, watch cat
       /proc/<pid>/maps);
       3. напишите функцию, которая будет выделять на стеке массив
       (например, 4096 байт) и рекурсивно вызывать себя;
       4. понаблюдайте как изменяется адресное пространство процесса
       (стек);
       5. напишите цикл, в котором на каждой итерации будет выделяться
       память на куче (подберите размер буфера сами). Используйте
       секундную паузу между итерациями.
       6. понаблюдайте как изменится адресное пространство процесса
       (heap);
       7. освободите занятую память.
       8. присоедините к процессу еще один регион адресов размером в 10 страниц (используйте mmap(2) с флагом ANONYMOUS).
       9. понаблюдайте за адресным пространством.
       10. измените права доступа к созданному региону и проверьте какая будет реакция, если их нарушить:
           1. запретите читать данные и попробуйте прочитать из региона.
           2. запретите писать и попробуйте записать.
       11. попробуйте перехватить сигнал SIGSEGV.
       12. отсоедините страницы с 4 по 6 в созданном вами регионе.
       13. понаблюдайте за адресным пространством.
   d. Чтобы было удобнее наблюдать за адресным пространством подберите удобные паузы между операциями изменяющими его.
   e. Объясните что происходит с адресным пространством в данной задаче.

3. Самодельная куча
    a. Реализуйте свою кучу над анонимным регионом адресов:
        i. присоедините анонимный регион (mmap(2));
        ii. реализуйте функцию my_malloc(), которая:
            1. принимает размер памяти в байтах;
            2. резервирует буфер запрошенного размера и возвращает
            указатель на его начало;
            3. при недостатке памяти возвращает NULL.
        iii. реализуйте функцию my_free(), которая:
            1. принимает указатель на буфер, возвращенный ранее функцией my_malloc();
            2. помечает буфер свободным;
        iv. Рекомендация. Для отладки можно присоединить регион связанный с файлом. Это позволит наблюдать за состоянием вашей кучи при выделении-освобождении памяти.
